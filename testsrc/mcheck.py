#
# Port of historical SCILAB code (mcheck.sce) that checks output files generated by mcheck.c
#

'''
// Script for checking the mcheck.c code

N=200;
mprintf("N=%i\n",N);
m=ceil(rand()*N);
n=ceil(rand()*N);
k=ceil(rand()*N);
cmdstr=sprintf("mcheck.exe %i %i %i",m,n,k);
mprintf("%s\n",cmdstr);
unix_w(cmdstr);

X=fscanfMat("X.dat");
Xt=fscanfMat("Xt.dat");
YpI=fscanfMat("YpI.dat");   // should be equal to X*X'+eye(m)
ZpI=fscanfMat("ZpI.dat");   // should be equal to X'*X+eye(n)
L1=fscanfMat("L1.dat");
L2=fscanfMat("L2.dat");
y=fscanfMat("y.dat");
z=fscanfMat("z.dat");
W=fscanfMat("W.dat");
XW=fscanfMat("XW.dat"); // should be equal to X*W

// Check that the random numbers in X are (close to) standard
mprintf("mean(X(:))=%f, stdev(X(:))=%f\n",mean(X(:)),stdev(X(:)));

// Now check that the matrices make sense by replication using the SCILAB routines...
mprintf("norm(X''-Xt)/norm(X'')=%.16e\n",norm(X'-Xt,'fro')/norm(X','fro'));
mprintf("norm(X*X''+I-YpI)/norm(YpI)=%.16e\n",norm(X*X'+eye(m,m)-YpI,'fro')/norm(YpI,'fro'));
mprintf("norm(X''*X+I-ZpI)/norm(ZpI)=%.16e\n",norm(X'*X+eye(n,n)-ZpI,'fro')/norm(ZpI,'fro'));
L1b=chol(X*X'+eye(m,m)); L1b=L1b';
L2b=chol(X'*X+eye(n,n)); L2b=L2b';
mprintf("norm(L1-L1b)/norm(L1b)=%.16e\n",norm(L1-L1b,'fro')/norm(L1b,'fro'));
mprintf("norm(L2-L2b)/norm(L2b)=%.16e\n",norm(L2-L2b,'fro')/norm(L2b,'fro'));
mprintf("norm(L1*L1''-YpI)/norm(YpI)=%.16e\n",norm(L1*L1'-YpI,'fro')/norm(YpI,'fro'));
mprintf("norm(L2*L2''-ZpI)/norm(ZpI)=%.16e\n",norm(L2*L2'-ZpI,'fro')/norm(ZpI,'fro'));
yb=L1'\(L1\ones(m,1));
zb=L2'\(L2\ones(n,1));
mprintf("norm(y-yb)/norm(yb)=%.16e\n",norm(y-yb,'fro')/norm(yb,'fro'));
mprintf("norm(z-zb)/norm(zb)=%.16e\n",norm(z-zb,'fro')/norm(zb,'fro'));
XWb=X*W;
mprintf("norm(XW-XWb)/norm(XWb)=%.16e\n",norm(XW-XWb,'fro')/norm(XWb,'fro'));

'''

import os
import argparse 
import numpy as np 

def frobnorm(X):
  return np.sqrt(np.sum(X * X))

if __name__ == '__main__':
  parser = argparse.ArgumentParser()

  parser.add_argument('--N', type = int, default = 0, help = 'maximum value of m,n,k (uniformly randomized if N > 0)')
  parser.add_argument('--m', type = int, default = 10, help = 'dimension m (overridden if N is given)')
  parser.add_argument('--n', type = int, default = 10, help = 'dimension n (overridden if N is given)')
  parser.add_argument('--k', type = int, default = 10, help = 'dimension k (overridden if N is given)')
  parser.add_argument('--tolerance', type = float, default = 1.0e-12, help = 'tolerance for test')
  parser.add_argument('--do-not-generate', action = 'store_true', help = 'do not call mcheck; only read files already existing')

  args = parser.parse_args()

  m = np.random.randint(1, args.N) if args.N > 0 else args.m
  n = np.random.randint(1, args.N) if args.N > 0 else args.n
  k = np.random.randint(1, args.N) if args.N > 0 else args.k

  if not args.do_not_generate:
    assert m >= 1 and n >= 1 and k >= 1 
    print([m,n,k])
    cmdstr = './mcheck {} {} {}'.format(m, n, k)
    print('executing: {}'.format(cmdstr))
    retval = os.system(cmdstr)
    assert retval == 0

  X   = np.loadtxt("X.dat")
  Xt  = np.loadtxt("Xt.dat")
  YpI = np.loadtxt("YpI.dat") # should be equal to X*X'+eye(m)
  ZpI = np.loadtxt("ZpI.dat") # should be equal to X'*X+eye(n)
  L1  = np.loadtxt("L1.dat")
  L2  = np.loadtxt("L2.dat")
  y   = np.loadtxt("y.dat")
  z   = np.loadtxt("z.dat")
  W   = np.loadtxt("W.dat")
  XW  = np.loadtxt("XW.dat")  # should be equal to X*W

  if args.do_not_generate:
    m = X.shape[0]
    n = X.shape[1]
    assert W.shape[0] == n
    k = W.shape[1]
    print([m,n,k])

  err1 = frobnorm(X.T - Xt) / frobnorm(X.transpose())
  assert err1 < args.tolerance 

  err2 = frobnorm(np.dot(X, X.T) + np.eye(m) - YpI) / frobnorm(YpI)
  assert err2 < args.tolerance 

  err3 = frobnorm(np.dot(X.T, X) + np.eye(n) - ZpI) / frobnorm(ZpI)
  assert err3 < args.tolerance 

  err4 = frobnorm(np.dot(L1, L1.T) - YpI) / frobnorm(YpI)
  assert err4 < args.tolerance 

  err5 = frobnorm(np.dot(L2, L2.T) - ZpI) / frobnorm(ZpI)
  assert err5 < args.tolerance 

  # TODO: independently compute L1, L2 and check
  # ... implement final tests ...

  assert True

